{
  "hash": "5331738af06bb2a64fde7f230a5bcd73",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Natural Language Processing using LLMs in R & Python :: Cheatsheet\"\ndescription: \" \"\nimage-alt: \"\"\nexecute:\n  eval: true\n  output: false\n  warning: false\n---\n\n\n::: {.cell .column-margin}\n<img src=\"images/logo-mall.png\" height=\"138\" alt=\"Hex logo for mall - drawing of the inside of a mall. There is a fountain in the middle.\" />\n<br><br><a href=\"../nlp-with-llms.pdf\">\n<p><i class=\"bi bi-file-pdf\"></i> Download PDF</p>\n<img src=\"../pngs/nlp-with-llms.png\" width=\"200\" alt=\"\"/>\n</a>\n<br><br>\n:::\n\n\n## Intro\n\n\n::: {.panel-tabset group=\"language\"}\n\n### R\n\nUse LLM’s to perform NLP row-wise over a data frame. `mall` comes with pre-defined\nprompts that perform specific NLP operations, and then places the results in a \nnew column. Use *OpenAI*, *Ollama*, *Anthropic* and many others thanks to its\nintegration with `ellmer`\n\n`mall`’s data frame functions are designed with ‘tidy’ principals in mind, so they\nwork with the Tidyverse packages. `mall` also includes functions that work with \nstring vectors.\n\n### Python\n\nUse LLM’s to perform NLP row-wise over a data frame. `mall` comes with pre-defined\nprompts that perform specific NLP operations, and then places the results in a \nnew column. Use *OpenAI*, *Ollama*, *Anthropic* and many others thanks to its \nintegration with `chatlas`\n\n`mall` works as an extension for **Polars** data frames. It also works with\nstring vectors.\n\n:::\n\n## Getting started\n\n::: {.panel-tabset group=\"language\"}\n\n### R\n\n1. Load the libraries\n    \n    ```r\n    library(mall)\n    library(ellmer)\n    ```\n    \n1. Create a vendor specific chat connection\n\n    ```r\n    chat <- chat_openai()\n    ```\n\n1. Pass the chat object to mall\n\n    ```r\n    llm_use(chat)\n    ````\n    \n- *For dataframes:*\n\n    ```r\n    data(“reviews\") # Sample product reviews\n    \n    reviews |>\n      llm_sentiment(review)\n    ```\n\n- *For vectors:*\n    \n    ```r\n    llm_vec_sentiment(c(\"I am happy\", \"I am sad”))\n    ```\n\n<br/>\n\n::: {style=\"font-size: 130%;\"}    \n**Connect automatically**\n:::\n\nAs a convenience, mall is able to automatically establish a connection with the \nLLM. To do this you can use the `.mall_chat` option: \n`options(.mall_chat=ellmer::chat_openai(model=\"gpt-4o\"))`\nAdd this line to your *.Rprofile * file in order for that code to run every \ntime you start R. You can call `usethis::edit_r_profile()` to edit.\n\n### Python\n\nStart by creating a new LLM connection\n\n```python\nfrom chatlas import ChatOpenAI\nchat = ChatOpenAI()\n```\n\n- *For Dataframes*\n\n  1. Load the library\n  \n      ```python\n      import mall\n      ```\n      \n  1. Read or load your data frame\n  \n      ```python\n      reviews = mall.MallData.reviews # Sample product\n      reviews\n      ```\n  1. Pass the chat object to mall\n  \n      ```python\n      reviews.llm.use(chat)\n      ```\n      \n  1. Access NLP functions via `.llm`\n      \n      ```python\n      reviews.llm.sentiment('review')\n      ```\n    \n- *For String vectors*\n\n  1. Load the LLMVec class\n  \n      ```python\n      from mall import LLMVec\n      ```\n  1. Create a new LLMVec object\n  \n      ```python\n      llm = LLMVec(chat)\n      ```\n      \n  1. Pass a vector to a function in the new object\n  \n      ```python\n      llm.sentiment(['I am happy', 'I am sad'])\n      ```\n    \n:::\n\n## NLP functions\n\n\n### Sentiment analysis \n\n::: {.panel-tabset group=\"language\"}\n\n### R\n\n- `llm_sentiment(.data, col, options = c(\"positive\", \"negative\", “neutral\"), pred_name = “.sentiment\", additional_prompt = “”)`\n\n    ```r\n    llm_sentiment(reviews, review)\n    ```\n\n- `llm_vec_sentiment(x, options = c(\"positive\", \"negative\", \"neutral\"), additional_prompt = \"\", preview = FALSE)`\n\n    ```r\n    llm_vec_sentiment(c(\"I am happy\", \"I am sad\"))\n    ```\n\n**Special arguments:**\n\n`options`: Customize the sentiments to check for: \n`options = c(“positive”, “negative”)`. Use ‘tilde’ to mask the results, for \nexample `c(\"positive\" ~ 1, \"negative\" ~ 0))` returns 1 for positive and 0 for\nnegative.\n\n### Python\n\n- *\\<Dataframe\\>*`.llm.sentiment(col, options = ['positive', 'negative', 'neutral'], additional='', pred_name ='sentiment')`\n\n    ```python\n    reviews.llm.sentiment('review')\n    ```\n\n- *\\<LLMVec object\\>*`.sentiment(x, options=['positive', 'negative', 'neutral'], additional='')`\n\n    ```python\n    llm.sentiment(['I am happy', 'I am sad'])\n    ```\n\n**Special arguments:**\n\n`options`:  Customize the sentiments to check for: \n`options = [\"positive\", \"negative\"]`. Use a DICT object to mask the results, \nfor example `{\"positive\": 1, \"negative\"  0}` returns 1 for positive and 0 for\nnegative.\n\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}